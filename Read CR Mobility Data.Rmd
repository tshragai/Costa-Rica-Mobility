---
title: "Costa Rica Mobility Read Data"
output: html_document
date: "2025-10-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Libraries and working directory
```{r set wd and libraries}
## packages
library(sf)
library(terra)
library(tidyverse)
library(tigris)
library(data.table)
library(leaflet)
library(RColorBrewer)
library(slippymath)
library(scales)
setwd("~/Downloads")
```



#Meta Activity Maps
- I only use visit_* tiles (not home_* tiles)
- I only use daytime observations (not nighttime)
##Step 1. Reduce memory burden
- The US csv file was quite large so I had to fiddle around with filtering/making sure my computer didn't explode (play around with this)
- This is Sam's flow to do the initial data processing
- Only need to run this once!

```{r}
library(data.table)

## -------- settings you can edit --------
input_dir   <- "~/Documents/CR meta mobility data"     
pattern     <- "\\.csv$"                          # only .csv files
chunk_size  <- 5000
lat_min <- 7.4; lat_max <- 11.4
lon_min <- -86.1; lon_max <- -82.8
country_filter <- "CR"
## --------------------------------------

csv_files <- list.files(input_dir, pattern = pattern, full.names = TRUE)

if (length(csv_files) == 0) {
  stop("No CSV files found in: ", input_dir)
}

# ----------------------------
# process a single CSV
# ----------------------------
process_one <- function(input_file, output_file) {
  # fresh output
  if (file.exists(output_file)) file.remove(output_file)
  
  con <- file(input_file, "r")
  on.exit(close(con), add = TRUE)
  
  header <- readLines(con, n = 1)
  if (length(header) == 0L) return(invisible(NULL))  # empty file
  
  repeat {
    chunk_lines <- readLines(con, n = chunk_size)
    if (length(chunk_lines) == 0L) break
    
    # build a small CSV string with header + this chunk
    chunk <- fread(paste(c(header, chunk_lines), collapse = "\n"))
    
    # filter + append to output
    chunk[
      visit_latitude  >= lat_min & visit_latitude  <= lat_max &
      visit_longitude >= lon_min & visit_longitude <= lon_max &
      country == country_filter
    ][
      , fwrite(.SD, output_file, append = TRUE)
    ]
  }
}

# ===========================================
##single combined output 
# ===========================================
# Uncomment to produce one big file with all filtered rows
 combined_out <- file.path(input_dir, "all_processed_combined.csv")
 if (file.exists(combined_out)) file.remove(combined_out)
 for (infile in csv_files) {
   message("Appending from: ", basename(infile))
   # temp file for this input, then append to combined to keep logic clean
   tmp_out <- tempfile(fileext = ".csv")
   process_one(infile, tmp_out)
   if (file.exists(tmp_out) && file.info(tmp_out)$size > 0) {
     # copy header only once, then append rows
     if (!file.exists(combined_out)) {
       file.copy(tmp_out, combined_out)
     } else {
       # append without header: read tmp and write append
       dt <- fread(tmp_out)
       fwrite(dt, combined_out, append = TRUE)
     }
   }
   unlink(tmp_out)
 }

# ===========================================
##per-file outputs (recommended)
# ===========================================
# Each input 'foo.csv' -> 'foo_processed.csv' in the same folder
for (infile in csv_files) {
  outfile <- sub("\\.csv$", "_processed.csv", infile)
  message("Processing: ", basename(infile), " -> ", basename(outfile))
  process_one(infile, outfile)
}
```


Now I'm trying to filter data to a single origin district and show connections
Maybe download health facility data from GEE
And we have health-facility level dengue data but it's messy? 

ok here's what I want to do tomorrow
make a shiny app where you can select a district and see
two maps (travel in and travel out) by Meta pixel 
use a base district map
Can caroline create a suitability map to underlay? Movement+suitability
Then bring in malaria and/or dengue data, ideally to health facility level 
Can you predict (an preemptively treat) transmission of rare or emerging diseases? 
Can you predict and prevent transmission of dengue at the beginning of the transmission season? 


```{r}
library(mapdeck)
library(stringi)
mapdeck::set_token("pk.eyJ1IjoidHNocmFnYWkiLCJhIjoiY21oam84d2JtMWRnOTJpcTY0Mm9uamVmaCJ9.G1P5tS1f60KuJBKTkM-9lQ")
mapdeck_tokens()

# normalize strings for matching
norm_str <- function(x) stri_trans_general(x, "Latin-ASCII") |> toupper() |> trimws()
target_name <- "SARAPIQUI"       # adjust if your shapefile uses another spelling
name_col    <- "NOMB_UGED"       # district name field in your `districts`

# Sarapiquí polygon (outline + context fill)
sar_poly <- districts %>%
  mutate(norm = norm_str(.data[[name_col]])) %>%
  filter(norm == target_name) %>%
  st_transform(4326)

# Tiles that fall inside the district (faint backdrop polygons)
tiles_in_district <- st_intersection(st_transform(pop_tiles, 4326), sar_poly) %>%
  select(tile_id)

# One centroid per tile (for arc endpoints), from existing pop_tiles
tile_centroids <- pop_tiles %>%
  st_transform(4326) %>%
  st_centroid() %>%
  transmute(tile_id,
            Lon = st_coordinates(geometry)[,1],
            Lat = st_coordinates(geometry)[,2]) %>%
  st_drop_geometry()

# Ensure weight column exists from your previous step
if (!"weight" %in% names(ca_aug)) {
  ca_aug <- ca_aug %>% mutate(weight = visit_fraction * origin_pop)
}

#comput origin and destination disitrcts
# make sure everything uses the same CRS
tiles_crs <- st_crs(districts)

# create sf objects for origins and destinations
origins_sf <- st_as_sf(
  ca_aug,
  coords = c("home_longitude", "home_latitude"),
  crs = 4326, remove = FALSE
) %>% st_transform(tiles_crs)

dest_sf <- st_as_sf(
  ca_aug,
  coords = c("visit_longitude", "visit_latitude"),
  crs = 4326, remove = FALSE
) %>% st_transform(tiles_crs)

# join with district polygons to find which district each point falls in
origins_joined <- st_join(origins_sf, districts[, c("NOMB_UGED")], left = TRUE)
dests_joined   <- st_join(dest_sf,   districts[, c("NOMB_UGED")], left = TRUE)

# extract just the district names, keeping row order
origin_districts <- st_drop_geometry(origins_joined) %>%
  transmute(origin_district = NOMB_UGED)

dest_districts <- st_drop_geometry(dests_joined) %>%
  transmute(dest_district = NOMB_UGED)

# add them back to your main data frame
ca_aug <- bind_cols(ca_aug, origin_districts, dest_districts)



# OUTGOING: origin must be in district; destination anywhere
flows_out <- ca_aug %>%
  mutate(origin_norm = norm_str(origin_district)) %>%
  filter(origin_norm == target_name, !is.na(o_tile_id), !is.na(d_tile_id)) %>%
  group_by(o_tile_id, d_tile_id) %>%
  summarise(weight = sum(weight, na.rm = TRUE), .groups = "drop")

# INCOMING: destination must be in district; origin anywhere
flows_in <- ca_aug %>%
  mutate(dest_norm = norm_str(dest_district)) %>%
  filter(dest_norm == target_name, !is.na(o_tile_id), !is.na(d_tile_id)) %>%
  group_by(o_tile_id, d_tile_id) %>%
  summarise(weight = sum(weight, na.rm = TRUE), .groups = "drop")

# helper: attach centroids and build the arc df mapdeck expects
prep_arc_df <- function(flows, cents) {
  df <- flows %>%
    left_join(cents %>% rename(o_tile_id = tile_id, Lon.home = Lon, Lat.home = Lat),
              by = "o_tile_id") %>%
    left_join(cents %>% rename(d_tile_id = tile_id, Lon = Lon, Lat = Lat),
              by = "d_tile_id") %>%
    filter(is.finite(Lon.home), is.finite(Lat.home), is.finite(Lon), is.finite(Lat),
           o_tile_id != d_tile_id) %>%
    mutate(
      w_log    = log1p(weight),
      stroke_w = rescale(w_log, to = c(1, 8), from = range(w_log, na.rm = TRUE)),
      # continuous color by weight (viridis palette via scales::col_numeric + viridisLite)
      color    = viridisLite::viridis(100)[as.integer(rescale(w_log, to = c(1, 100)))],
      tooltip  = sprintf(
        "OD tiles: %s → %s<br/>Weight: %.3f",
        o_tile_id, d_tile_id, weight
      )
    )
  df
}

loc.df.out <- prep_arc_df(flows_out, tile_centroids)
loc.df.in  <- prep_arc_df(flows_in,  tile_centroids)

# Optional: throttle tiny flows to declutter (quantile cut)
# q_out <- quantile(loc.df.out$weight, 0.90, na.rm = TRUE); loc.df.out <- loc.df.out %>% filter(weight >= q_out)
# q_in  <- quantile(loc.df.in$weight,  0.90, na.rm = TRUE); loc.df.in  <- loc.df.in  %>% filter(weight >= q_in)

# Backdrop polygon layer wants a 'color' column; give a faint fixed color
clust_out <- tiles_in_district %>% mutate(color = "#31a354")
clust_in  <- tiles_in_district %>% mutate(color = "#3182bd")

# target and helper (same as before)
norm_str   <- function(x) stri_trans_general(x, "Latin-ASCII") |> toupper() |> trimws()
target_name <- "SARAPIQUI"      # change if needed
name_col    <- "NOMB_UGED"      # district name field in your shapefile

# all districts (background) + target district (highlight)
districts_full <- st_transform(districts, 4326)

sar_poly <- districts_full %>%
  mutate(norm = norm_str(.data[[name_col]])) %>%
  filter(norm == target_name)

## -------- Map A: ORIGIN in district (→ anywhere) --------
tripmap_out <- mapdeck(style = mapdeck_style("dark"), pitch = 45) %>%
  # BACKDROP: all districts, subtle
  add_polygon(
    data          = districts_full,
    stroke_colour = "#666666",
    stroke_width  = 1,
    fill_colour   = "#222222",
    fill_opacity  = 0.08
  ) %>%
  # HIGHLIGHT: target district on top
  #add_polygon(
   # data          = sar_poly,
    #stroke_colour = "#FFD166",
    #stroke_width  = 6,
    #fill_colour   = "#FFD166",
    #fill_opacity  = 0.25
  #) %>%
  # arcs & points (unchanged)
  add_arc(
    data         = loc.df.out,
    layer_id     = "arc_layer_out",
    origin       = c("Lon.home", "Lat.home"),
    destination  = c("Lon", "Lat"),
    stroke_from  = "#FFFFFF",
    stroke_to    = "color",
    stroke_width = "stroke_w",
    brush_radius = 610,
    tooltip      = "tooltip",
    legend       = TRUE,
    legend_options = list(
      stroke_to = list(title = "Flow weight (log-scaled)"),
      css = "max-height: 120px;"
    )
  ) %>%
  add_scatterplot(
    data        = loc.df.out,
    layer_id    = "origin_pts_out",
    lat         = "Lat.home",
    lon         = "Lon.home",
    fill_colour = "grey",
    radius      = 15,
    legend      = FALSE
  )

## -------- Map B: DESTINATION in district (← anywhere) --------
tripmap_in <- mapdeck(style = mapdeck_style("dark"), pitch = 45) %>%
  # BACKDROP: all districts, subtle
  add_polygon(
    data          = districts_full,
    stroke_colour = "#666666",
    stroke_width  = 1,
    fill_colour   = "#222222",
    fill_opacity  = 0.08
  ) %>%
  # HIGHLIGHT: target district on top
 # add_polygon(
  #  data          = sar_poly,
   # stroke_colour = "#8EC1FF",
  #  stroke_width  = 6,
  #  fill_colour   = "#8EC1FF",
   # fill_opacity  = 0.25
  #) %>%
  # arcs & points (unchanged)
  add_arc(
    data         = loc.df.in,
    layer_id     = "arc_layer_in",
    origin       = c("Lon.home", "Lat.home"),
    destination  = c("Lon", "Lat"),
    stroke_from  = "#FFFFFF",
    stroke_to    = "color",
    stroke_width = "stroke_w",
    brush_radius = 610,
    tooltip      = "tooltip",
    legend       = TRUE,
    legend_options = list(
      stroke_to = list(title = "Flow weight (log-scaled)"),
      css = "max-height: 120px;"
    )
  ) %>%
  add_scatterplot(
    data        = loc.df.in,
    layer_id    = "dest_pts_in",
    lat         = "Lat",
    lon         = "Lon",
    fill_colour = "grey",
    radius      = 15,
    legend      = FALSE
  )

tripmap_out
tripmap_in



##########################################
# ----- 1) Backdrop layers: grey fill + crisp outlines -----
districts_grey <- districts_full %>%
  st_transform(4326) %>%
  mutate(fill_hex   = "#EAEAEA")

districts_lines <- districts_full %>%
  st_transform(4326) %>%
  st_make_valid() %>%
  st_boundary() %>%
  st_cast("MULTILINESTRING") %>%
  st_as_sf() %>%
  mutate(stroke_hex = "#555555")

# Country bbox (nice to frame the view)
bbox_cr <- st_bbox(districts_full %>% st_transform(4326))

# ----- 2) Focal tiles inside district + OUTGOING weight per ORIGIN tile -----
tiles_in_district <- st_intersection(st_transform(pop_tiles, 4326), sar_poly) %>%
  select(tile_id)

tile_out_weights <- flows_out %>%
  group_by(o_tile_id) %>%
  summarise(out_weight = sum(weight, na.rm = TRUE), .groups = "drop")

tiles_out_fill <- tiles_in_district %>%
  left_join(tile_out_weights, by = c("tile_id" = "o_tile_id")) %>%
  mutate(out_weight = ifelse(is.na(out_weight), 0, out_weight))

# ----- 3) Map (only legend = out_weight) -----

tripmap_out <- mapdeck(
  style    = "mapbox://styles/mapbox/streets-v12",
  location = c(-84.09, 9.93),
  zoom     = 6,
  pitch    = 45
) %>%
  # B) crisp outlines
  add_path(
    data           = districts_lines,
    layer_id       = "districts_outline",
    stroke_colour  = "stroke_hex",
    stroke_width   = 1.5,
    stroke_opacity = 0.9,
    legend         = FALSE
  ) %>%
  # C) focal district tiles colored by OUTGOING weight
  add_polygon(
    data          = tiles_out_fill,
    layer_id      = "focal_tiles_out",
    stroke_colour = "#F2A900",
    stroke_width  = 0.7,
    fill_colour   = "out_weight",
    fill_opacity  = 0.70,
    palette       = "viridis",
    legend        = TRUE,
    legend_options = list(
      fill_colour = list(title = "Outgoing flow (out_weight)")
    )
  ) %>%
  # D) arcs from origin tiles inside district to anywhere (no legend)
  add_arc(
    data         = loc.df.out,
    layer_id     = "arc_layer_out",
    origin       = c("Lon.home","Lat.home"),
    destination  = c("Lon","Lat"),
    stroke_from  = "#FFFFFF",
    stroke_to    = "color",
    stroke_width = "stroke_w",
    brush_radius = 610,
    tooltip      = "tooltip",
    legend       = FALSE
  ) %>%
  # E) optional: plot origin tile points (no legend)
  add_scatterplot(
    data        = loc.df.out,
    layer_id    = "origin_pts_out",
    lat         = "Lat.home",
    lon         = "Lon.home",
    fill_colour = "grey",
    radius      = 15,
    legend      = FALSE
  ) 
tripmap_out



########
library(manipulate)
library(mapdeck)

manipulate(
  {
    mapdeck(
      style    = "mapbox://styles/mapbox/streets-v12",
      location = c(-84.09, 9.93),
      zoom     = 6,
      pitch    = pitch
    ) %>%
      add_arc(
        data = loc.df.out,
        origin = c("Lon.home","Lat.home"),
        destination = c("Lon","Lat"),
        stroke_from = "#FFFFFF",
        stroke_to = "color",
        stroke_width = "stroke_w"
      )
  },
  pitch = slider(0, 60, step = 5, initial = 45, label = "Map pitch")
)

```


###########Next things
1. Create a matrix that shows how connected each district is to each other district
2. Movement within district vs movement between district
3. Median distance of travel 
4. Connections to certain districts 
5. Seasonal movement -> seasonal dengue
6. Can you see movement after a natural disasaster (and then link this back to dengue)?
   -try flooding in Nov 2024, we do not have 2024 data
7. 




